#SSM练习第4
##大纲内容
1. 用户角色权限表结构
2. 用户退出功能
3. 用户添加/列表查询
4. 角色列表功能
5. 权限资源添加/列表功能
6. 用户信息查询
7. 用户权限动态校验


### 第1章 用户角色模块
#### 1.1 用户角色权限模块表结构
![权限5表](./权限5表.png)

##### 1.1.1 角色表
###### 1.1.1.1 角色表信息描述role

| 序号   | 字段名称     | 字段类型     | 字段描述    |
| ---- | -------- | -------- | ------- |
| 1    | id       | number   | 主键，自动增长 |
| 2    | roleName | varchar2 | 角色名     |
| 3    | roleDesc | varchar2 | 角色描述    |

###### 1.1.1.2 SQL语句
```plsql
--角色表
CREATE TABLE sys_role(
  id number(5) PRIMARY KEY,
  roleName VARCHAR2(50),
  roleDesc VARCHAR2(50)
);
--主键序列
create sequence sys_role_seq;
```

###### 1.1.1.3 实体类
```java
public class SysRole {
    private Integer id;
    private String roleName;
    private String roleDesc;
    //一个角色可以授予多个用户，角色和用户之间属于一对多关系,彼此之间属于多对多关系
    private List<SysUser> users;
    //一个角色可以有多个权限，角色和权限之间属于一对多关系，彼此之间属于多对多关系
    private List<SysPermisson> permissions;

	//get...set...
}
```

##### 1.1.2 用户与角色关联关系
用户与角色之间是多对多关系，我们通过user_role表来描述其关联，在实体类中User中存在List<SysRole>，在SysRole中有List<SysUser>.而角色与权限之间也存在关系，我们会在后面介绍。
​	
```plsql
--建表语句
CREATE TABLE sys_user_role(
  userId number(5),
  roleId number(5),
  PRIMARY KEY(userId,roleId),
	FOREIGN KEY (userId) REFERENCES sys_USER(id),
	FOREIGN KEY (roleId) REFERENCES sys_role(id)
);
```


##### 1.1.3 权限资源表
权限资源表描述permission

| 序号   | 字段名称           | 字段类型     | 字段描述    |
| ---- | -------------- | -------- | ------- |
| 1    | id             | number   | 主键，自动增长 |
| 2    | permissionName | varchar2 | 权限名     |
| 3    | url            | varchar2 | 资源路径    |
| 4    | pid            | number   | 上级菜单编号  |


```plsql
--资源权限表
CREATE TABLE sys_permission(
	id number(5) PRIMARY KEY,
	permissionName VARCHAR2(50) ,
	url VARCHAR2(50),
	pid number(5)
);
--主键序列
create sequence sys_permission_seq;
```

###### 1.1.3.1 实体类
```java
public class SysPermission {
    private Long id;
    private String permissionName;
    private String url;
    private Long pid;
    //一个权限可以授予多个角色，权限和角色之间属于一对多关系，彼此之间属于多对多关系
    private List<SysRole> rols;
	//get..set...
}
```


##### 1.1.4 权限资源与角色关联关系
权限资源与角色是多对多关系，我们使用role_permission表来描述。在实体类SysPermission中存在List<SysRole>,在Role类中有List<SysPermission>

```plsql
--资源角色表
CREATE TABLE sys_role_permission(
	permissionId number(5),
	roleId number(5),
	PRIMARY KEY(permissionId,roleId),
	FOREIGN KEY (permissionId) REFERENCES sys_permission(id),
	FOREIGN KEY (roleId) REFERENCES sys_role(id)
);
```



#### 1.2 用户退出功能
在header.jsp的页面中编写超链接

```html
<a href="${pageContext.request.contextPath}/logout" class="btn btn-default btn-flat">注销</a>
```


#### 1.3 用户的列表查询功能
##### 1.3.1 Controller代码

​	创建UserController

```java
package com.itheima.controller;

import com.github.pagehelper.PageInfo;
import com.itheima.domain.SysUser;
import com.itheima.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;

    /***
     * 用户分页查询
     * @return
     */
    @RequestMapping(value = "/list")
    public String list(@RequestParam(value="page",required=false,defaultValue="1")int page,
                        @RequestParam(value="size",required=false,defaultValue="5")int size,
                        Model model){
        //分页查询
        PageInfo<SysUser> pageInfo = userService.pageList(page,size);
        model.addAttribute("pageInfo",pageInfo);
        return "user-list";
    }
}
```

##### 1.3.2 Service代码


```java
// 在UserService接口中添加以下方法
/**
 * 用户分页查询-接口
 * @return
 * @param page
 * @param size
 */
PageInfo<SysUser> pageList(int page, int size);

// 在UserServiceImpl实现顺中添加实现
 /***
 * 用户分页查询，使用pageHelper
 * @param page
 * @param size
 * @return
 */
@Override
public PageInfo<SysUser> pageList(int page, int size) {
    //分页
    PageHelper.startPage(page,size);
    //集合查询
    List<SysUser> sysUsers = userDao.list();
    return new PageInfo<SysUser>(sysUsers);
}
```

##### 1.3.3 Dao代码
```java
 /***
 * 查询所有
 * @return
 */
@Select("select * from sys_user")
List<SysUser> list();
```

##### 1.3.4 JSP页面
```jsp
<tbody>
	<c:forEach items="${pageInfo.list}" var="user">
		<tr>
			<td><input name="ids" type="checkbox"></td>
			<td>${user.id }</td>
			<td>${user.username}</td>
			<td>${user.email}</td>
			<td>${user.phoneNum}</td>
			<td>
				<c:if test="${user.status==1}">正常</c:if>
				<c:if test="${user.status==2}">禁止登陆</c:if>
			</td>
			<td class="text-center">
				<a href="${pageContext.request.contextPath}/pages/user-show.jsp" class="btn bg-olive btn-xs">详情</a>
				<a href="${pageContext.request.contextPath}/pages/user-role-add.jsp" class="btn bg-olive btn-xs">添加角色</a>
			</td>
		</tr>
	</c:forEach>
</tbody>

<div class="box-footer">
	<div class="pull-left">
		<div class="form-group form-inline">
            当前第${pageInfo.pageNum}页/总共${pageInfo.pages}页，共${pageInfo.total}条数据。
            每页 <select class="form-control" onchange="submitPageSize(this)">
            <option <c:if test="${pageInfo.pageSize == 3}"> selected</c:if>>3</option>
            <option <c:if test="${pageInfo.pageSize == 5}"> selected</c:if>>5</option>
            <option <c:if test="${pageInfo.pageSize == 10}"> selected</c:if>>10</option>
            <option <c:if test="${pageInfo.pageSize == 20}"> selected</c:if>>20</option>
            <option <c:if test="${pageInfo.pageSize == 50}"> selected</c:if>>50</option>
        </select> 条
        </div>
	</div>
    <script type="text/javascript">
        function submitPageSize(opt){
            location.href="/user/list?page=1&size=" + opt.value
        }
    </script>
	<div class="box-tools pull-right">
        <ul class="pagination">
            <li><a href="/user/list?page=1&size=${pageInfo.pageSize}" aria-label="Previous">首页</a></li>
            <li><a href="/user/list?page=${pageInfo.prePage}&size=${pageInfo.pageSize}">上一页</a></li>
            <c:forEach var="i" begin="1" end="${pageInfo.pages}" varStatus="s">
                <%-- 取当前循环到第几个--%>
                <c:if test="${s.count <=5}">
                    <li><a href="/user/list?page=${i}&size=${pageInfo.pageSize}">${i}</a></li>
                </c:if>
                <c:if test="${s.count ==5}">
                    <li><a href="">...</a></li>
                </c:if>
            </c:forEach>
            <li><a href="/user/list?page=${pageInfo.nextPage}&size=${pageInfo.pageSize}">下一页</a></li>
            <li><a href="/user/list?page=${pageInfo.pages}&size=${pageInfo.pageSize}" aria-label="Next">尾页</a></li>
        </ul>
    </div>
</div>
```



#### 1.4 用户添加功能
	1. MD5加密介绍
	   1. MD5是一个加密的算法，可以对铭文字符串进行加密，得到一个密文。
	   2. MD5原文和密文是一对一的键值对。
	      1. 例如：原文：123 密文：202cb962ac59075b964b07152d234b70
	      2. 不管执行多少次，加密算法是固定的，得到的密文永远不变
	      3. 相对来说就不安全，容易被破解
	   3. 公司中使用MD5进行加密
	      1. 例如：原文密码是123，把首尾交换，再加上用户名进行加密
	      2. 例如：321meimei 进行加密e5212215b8cbf493e04f4290cf7cecc8
	      3. 这样做相对来说会安全
	2. BCryptPasswordEncoder加密（加盐加密算法）
	   1. shiro框架有md5hash算法加密，该加密是加盐的方式进行加密的。
	   2. 在原有的密码中随机加入盐（就是字符串），再进行加密。
			Md5Hash h = new Md5Hash("123","ha",2);
			System.out.println(h.toString());
	
			shiro加盐加密需要导入依赖包
			
			<!--使用shiro加盐密码-->
	        <dependency>
	            <groupId>org.apache.shiro</groupId>
	            <artifactId>shiro-all</artifactId>
	            <version>1.2.3</version>
	        </dependency>
	 
		3. 测试代码
	       	// $2a$10$.W5msBQws5yoJum7gEbMcOQ1J.p2UIjEH5l4lm1rLCers9QUhUVFS
	       	// $2a$10$UxZneVG78UkChbx4sZND7.mWWx6ulbnl38updtSMRK0KQw5QvEdUy
	       	public static void main(String[] args) {
	       		// System.out.println(md5("321meimei"));
	       		
	       		BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
	       		// String str = encoder.encode("123");
	       		// System.out.println(str);
	       		
	       		// 进行判断
	       		boolean b = encoder.matches("123", "$2a$10$UxZneVG78UkChbx4sZND7.mWWx6ulbnl38updtSMRK0KQw5QvEdUy");
	       		System.out.println(b);
	       	}	

##### 1.4.1 用户添加不带加密实现
###### 1.4.1.1 Controller代码
```java
/**
 * 用户添加
 * @param user
 * @return
 */
@RequestMapping(value = "/add")
public String add(SysUser user){
    //添加用户
    int acount = userService.add(user);
    return "redirect:/user/list";
}
```

###### 1.4.1.2 Service代码
```java
/***
 * 增加用户-接口
 * @param user
 * @return
 */
int add(SysUser user);

/***
 * 实现类
 * @param user
 * @return
 */
@Override
public int add(SysUser user) {
  
    return userDao.add(user);
}
```


###### 1.4.1.3 Dao代码
主键采用序列方式，所以先创建好序列。

```java
--创建序列
create sequence user_seq;

/***
 * 增加用户
 * @param user
 * @return
 */
@Insert("insert into sys_user(id,username,email,password,phonenum,status)values(user_sql.nextval,#{username},#{email},#{password},#{phoneNum},#{status})")
int add(SysUser user);
```


###### 1.4.1.4 JSP页面
修改user-add.jsp下form表单提交地址即可

	<form action="${pageContext.request.contextPath}/user/add" method="post">
		//...略
	</form>


##### 1.4.2 用户添加实现密码加密
在spring-security.xml中注入加密对象

```xml
<!--加密对象-->
<bean id="bCryptPasswordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder" />
```

在UserServiceImpl中添加密码加密操作

```java
/**
 * 用户添加
 * @param user
 * @return
 */
@Override
public int add(SysUser user) {
    //对密码进行加密
    user.setPassword(encoder.encode(user.getPassword()));
    return userDao.add(user);
}
```



#### 1.5 修改登录功能
用户之前采用未加密方式，现在采用了加密方式，所以加密方式和之前有所不一样，这时候我们需要改变Springsecurity的授权认证方式，指定加密对象。

修改spring-security.xml，如下

```xml
<!--配置授权信息-->
<security:authentication-manager>
    <!--使用自定义认证器-->
    <security:authentication-provider user-service-ref="userServiceImpl">
        <!--指定加密方式-->
        <security:password-encoder ref="bCryptPasswordEncoder" />
    </security:authentication-provider>
</security:authentication-manager>
```


去掉自定义认证类UserServiceImpl.loadUserByUsername方法中的{noop}，代码如下：

```java
//修改前：
User user = new User(username, "{noop}"+sysUser.getPassword(), authorities) ;

//修改后：
User user = new User(username, sysUser.getPassword(), authorities) ;
```


#### 1.6 角色列表查询
角色列表这里的分页作为同学们的课后作业去实现。为了能查询到数据，我们手动在数据库中增加2条角色信息然后列表查询出来，增加的SqL语句如下：

```plsql
insert into sys_role(id,rolename,roledesc)values(sys_role_seq.nextval,'ROLE_USER','普通用户');
insert into sys_role(id,rolename,roledesc)values(sys_role_seq.nextval,'ROLE_ADMIN','管理员');
```

##### 1.6.1 角色列表查询
###### 1.6.1.1 Controller代码
```java
@Controller
@RequestMapping(value = "/role")
public class RoleController {

    @Autowired
    private RoleService roleService;

    /***
     * 角色列表
     * @param model
     * @return
     */
    @RequestMapping(value = "/list")
    public String list(Model model){
        List<SysRole> roles = roleService.list();
        model.addAttribute("roles",roles);
        return "role-list";
    }
}
```

###### 1.6.1.2 Service代码
```java
//接口
public interface RoleService {
    List<SysRole> list();
}

//实现类
@Service
public class RoleServiceImpl implements RoleService {

    @Autowired
    private RoleDao roleDao;

    @Override
    public List<SysRole> list() {
        return roleDao.list();
    }
}
```


###### 1.6.1.3 Dao代码
```java
public interface RoleDao {
    /**
     * 集合查询
     * @return
     */
    @Select("select * from sys_role")
    List<SysRole> list();
}
```

###### 1.6.1.4 JSP页面

修改role-list.jsp文件

```jsp
<tbody>
	<c:forEach items="${roles}" var="role">
		<tr>
			<td><input name="ids" type="checkbox"></td>
			<td>${role.id}</td>
			<td>${role.roleName}</td>
			<td>${role.roleDesc}</td>
			<td class="text-center">
				<a href="${pageContext.request.contextPath}/pages/role-permission-add.jsp" class="btn bg-olive btn-xs">添加权限</a>
			</td>
		</tr>
	</c:forEach>
</tbody>
```



#### 1.7 权限资源列表
##### 1.7.1 Controller代码
```java
@Controller
@RequestMapping(value = "/permisson")
public class PermissonController {

    @Autowired
    private PermissonService permissonService;

    /***
     * 集合查询
     * @param model
     * @return
     */
    @RequestMapping(value = "/list")
    public String list(Model model){
        List<SysPermisson> sysPermissons = permissonService.list();
        model.addAttribute("sysPermissons",sysPermissons);
        return "permission-list";
    }
} 
```

##### 1.7.2 Service代码
```java
//接口
public interface PermissonService {
    List<SysPermisson> list();
}

//实现类
@Service
public class PermissonServiceImpl implements PermissonService {

    @Autowired
    private PermissonDao permissonDao;

    @Override
    public List<SysPermisson> list() {
        return permissonDao.list();
    }
}
```


##### 1.7.2 Dao代码
```java
public interface PermissonDao {
    /***
     * 查询所有权限资源
     * @return
     */
    @Select("select * from sys_permission")
    List<SysPermisson> list();
}
```

##### 1.7.3 JSP页面
```jsp
<tbody>
	<c:forEach items="${sysPermissons}" var="permission">
		<tr>
			<td><input name="ids" type="checkbox"></td>
			<td>${permission.id }</td>
			<td>${permission.permissionName }</td>
			<td>${permission.url }</td>													
			<td class="text-center">
				<a href="${pageContext.request.contextPath}/pages/permission-add.jsp" class="btn bg-olive btn-xs">详情</a>
			</td>
		</tr>
	</c:forEach>
</tbody>
```


#### 1.8 权限资源添加
##### 1.8.1 Controller代码

修改PermissionController

```java
@RequestMapping("/initAdd")
public String initAdd(){
    return "permission-add";
}

/***
 * 添加权限资源
 * @param sysPermisson
 * @return
 */
@RequestMapping(value = "/add")
public String add(SysPermisson sysPermisson){
    int acount = permissonService.add(sysPermisson);
    return "redirect:/permisson/list";
}
```

##### 1.8.2 Service代码
```java
//PermissionService 接口
int add(SysPermisson sysPermisson);

//PermissionServiceImpl 实现类
@Override
public int add(SysPermisson sysPermisson) {
    return permissonDao.add(sysPermisson);
}
```

##### 1.8.3 Dao代码

```java
// PermissionDao接口
/***
 * 添加资源操作
 * @param sysPermisson
 * @return
 */
@Insert("insert into sys_permission(id,permissionName,url,pid)values(permission_seq.nextval,#{permissionName},#{url},#{pid})")
int add(SysPermisson sysPermisson);
```


##### 1.8.4 JSP页面
permission-add.jsp页面修改下提交地址即可。

```jsp
<form action="${pageContext.request.contextPath}/permisson/add" method="post">
	//略....
</form>
```


#### 1.9 手动指定用户角色以及角色和权限之间的关系
	------------------------------------------
	角色ID     角色     
	  1       普通用户   ROLE_USER
	  2       管理员     ROLE_ADMIN


	用户ID    用户名字
	  1        admin
	  2        xiaohong
	
	在sys_user_role中添加映射关系，手动实现：
	USERID       ROLEID
	  1            2
	  2            1
	-------------------------------------------
	admin--->普通用户
	xiaohong-->管理员


	管理员  2
		用户管理		6
		角色管理		7
		权限管理		8
		
	普通用户 1
		产品管理		9
		订单管理		10
	
	在sys_role_permission中手动添加角色和权限的关系
	permissionid    roleID
		6				2
		7				2
		8				2
	
		9				1
		10				1
	-------------------------------------------

### 第2章 用户/角色/权限信息关联查询

#### 2.1 查询用户实现的效果
通过查询用户，然后查看用户的角色信息，再查看用户的授权信息，效果如下：

![](./用户信息.png)

#### 2.2 实现思路分析
我们可以分为3个步骤实现，第1步：查询用户信息，第2步：根据用户的id查询用户的角色信息，但角色信息需要关联用户角色表(sys_user_role)，第3步：查询用户菜单信息。实现的SQL语句如下：

```plsql
--查询用户
select * from sys_user where id=1;

--查询对应角色
select * from sys_user_role sur,sys_role sr where sur.userid=sr.id and id=1;

--查询菜单信息
select * from sys_role_permission srp,sys_permission sp where srp.permissionid=sp.id and srp.roleid=1
```

#### 2.3 映射关系分析
用户与角色的关系属于多对多关系，角色和权限的关系也属于多对多，我们可以通过这种映射关系来实现数据查找，而多对多在MyBatis注解中可以通过@Result(many=@Many(...))实现。我们可以先加载用户，再通过@Result(many=@Many(...))加载用户的角色信息，还可以通过角色的查询再加载授权信息。

### 2.4 代码实现
#### 2.4.1 Controller
在SysUserController中添加查询代码

```java
/***
 * 查询用户信息
 * @param id
 * @param model
 * @return
 */
@RequestMapping(value = "/show")
public String show(long id,Model model){
    //根据ID查询用户信息
    SysUser sysUser = userService.getById(id);

    //将信息存入Model
    model.addAttribute("sysUser",sysUser);
    return "user-show";
}
```


#### 2.4.2 Service代码
```java
/***
 * 接口
 * 查询用户信息
 * @param id
 * @return
 */
SysUser getById(long id);

/***
 * 查询用户信息-实现类
 * @param id
 * @return
 */
@Override
public SysUser getById(long id) {
    return userDao.getById(id);
}
```

#### 2.4.3 Dao代码
##### 2.4.3.1 UserDao代码
```java
/***
 * 查询用户信息
 * @param id
 * @return
 */
@Select(value = "select * from sys_user where id=#{id}")
@Results(
        //根据用户信息查询角色信息
        @Result(property ="roles",column = "id",
                many = @Many(select = "com.itheima.dao.RoleDao.getByUserId",
                        fetchType = FetchType.LAZY))
)
SysUser getById(long id);
```


##### 2.4.3.2 RoleDao代码
```java
/***
 * 根据用户信息查询角色信息
 */
@Select("select * from sys_user_role sur,sys_role sr where sur.userid=sr.id and id=#{id}")
@Results(
        //根据角色ID查询权限信息
        @Result(property = "permissions",column = "roleid",
                many = @Many(select = "com.itheima.dao.PermissonDao.getByRoleId",
                        fetchType = FetchType.LAZY))
)
List<SysRole> getByUserId(Long id);
```

##### 2.4.3.3 PermissonDao代码
```java
/***
 * 根据角色ID查询权限信息
 * @return
 */
@Select("select * from sys_role_permission srp,sys_permission sp where srp.permissionid=sp.id and srp.roleid=#{id}")
List<SysPermisson> getByRoleId(Long id);
```

#### 2.4.4 JSP页面
```jsp
<tbody>
	<c:forEach items="${sysUser.roles}" var="role" varStatus="s1" >
	<tr data-tt-id="${s1.count}" data-tt-parent-id="0">
		<td>${role.roleName }</td>
		<td>${role.roleDesc }</td>
	</tr>
	<c:forEach items="${role.permissions}" var="permission" varStatus="s2">
		<tr data-tt-id="${s1.count}-${s2.count}" data-tt-parent-id="${s1.count}">
			<td>${permission.permissionName}</td>
			<td>${permission.url}</td>
		</tr>
	</c:forEach>
</c:forEach>
</tbody>
```


### 第3章 用户授权
#### 3.1 角色从数据库加载
##### 3.1.1 修改自定义授权认证类
之前我们的用户授权角色写死了，现在应该把它写成从数据库检索。修改自定义认证类，代码如下：

```java
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    //通过账号查询用户信息
    SysUser sysUser = userDao.getByUserName(username);

    if(sysUser!=null){
        // 先设置假的权限
        List<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>();

        //获取用户角色
        List<SysRole> roles = sysUser.getRoles();

        for (SysRole role : roles) {
            // 传入角色
            authorities.add(new SimpleGrantedAuthority(role.getRoleName()));
        }

        // 创建认证信息并进行返回
        User user = new User(username, sysUser.getPassword(), authorities) ;
        return user;
    }
    return null;
}
```

##### 3.1.2 修改UserDao
直接修改Dao，通过@Many调用com.itheima.dao.RoleDao.getByUserId查询用户的角色信息。

```java
/***
 * 查询用户信息
 * @param name
 * @return
 */
@Select("select * from sys_user where username=#{username}")
@Results(
        //根据用户信息查询角色信息
        @Result(property ="roles",column = "id",
                many = @Many(select = "com.itheima.dao.RoleDao.getByUserId",
                        fetchType = FetchType.LAZY))
)
SysUser getByUserName(String name);
```


#### 3.2 access属性的配置
1. access的值是一个字符串，其可以直接是一个权限的定义，也可以是一个表达式。常用的类型有简单的角色名称定义，多个名称之间用逗号分隔。

  ```xml
   <security:intercept-url pattern="/**" access="ROLE_USER,ROLE_ADMIN"/>
   在上述配置中就表示secure路径下的所有URL请求都应当具有ROLE_USER或ROLE_ADMIN权限。当access的值是以“ROLE_”开头的则将会交由RoleVoter进行处理。
  ```

  2. 此外，其还可以是一个表达式

   ```xml
   <!--开启表达式 use-expressions="true" 才可以使用 spel-->
   <security:intercept-url pattern="/secure/**" access="hasAnyRole('ROLE_USER','ROLE_ADMIN')"/>
   ```

   ​

2. 或者是使用hasRole()表达式，然后中间以or连接

   ```xml
   <security:intercept-url pattern="/secure/**" access="hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')"/>
   ```

3. 其他的值

      * IS_AUTHENTICATED_ANONYMOUSLY表示用户不需要登录就可以访问
      * IS_AUTHENTICATED_REMEMBERED表示用户需要是通过Remember-Me功能进行自动登录的才能访问
      * IS_AUTHENTICATED_FULLY表示用户的认证类型应该是除前两者以外的，也就是用户需要是通过登录入口进行登录认证的才能访问
